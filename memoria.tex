\documentclass[a4paper,10pt]{article}
% Símbolo del euro
\usepackage[gen]{eurosym}
% Codificación
\usepackage[utf8]{inputenc}
% Idioma
\usepackage[spanish]{babel} % English language/hyphenation
\selectlanguage{spanish}
% Hay que pelearse con babel-spanish para el alineamiento del punto decimal
\decimalpoint
\usepackage{dcolumn}
\newcolumntype{d}[1]{D{.}{\esperiod}{#1}}
\makeatletter
\addto\shorthandsspanish{\let\esperiod\es@period@code}
\makeatother
% To work with bibtex
%\usepackage{natbib}
\usepackage[backend=bibtex,style=numeric,sorting=none]{biblatex}
\bibliography{references}
\usepackage{longtable}
\usepackage{tabu}
\usepackage{supertabular}

\usepackage{multicol}
\newsavebox\ltmcbox

% Para algoritmos
%\usepackage{algorithm}
%\usepackage{algorithmic}
\usepackage{amsthm}
% Para matrices
\usepackage{amsmath}

% Símbolos matemáticos
\usepackage{amssymb}
\let\oldemptyset\emptyset
\let\emptyset\varnothing

% Hipervínculos
\usepackage{url}

\usepackage[section]{placeins} % Para gráficas en su sección.
\usepackage{mathpazo} % Use the Palatino font
\usepackage[T1]{fontenc} % Required for accented characters
\newenvironment{allintypewriter}{\ttfamily}{\par}
\setlength{\parindent}{0pt}
\parskip=8pt
\linespread{1.05} % Change line spacing here, Palatino benefits from a slight increase by default


% Imágenes
\usepackage{graphicx}
\usepackage{float}
\usepackage{caption}
\usepackage{wrapfig} % Allows in-line images

% Referencias
\usepackage{fncylab}
\labelformat{figure}{\textit{\figurename\space #1}}

\usepackage{hyperref}
\hypersetup{
  colorlinks   = true, %Colours links instead of ugly boxes
  urlcolor     = blue, %Colour for external hyperlinks
  linkcolor    = blue, %Colour of internal links
  citecolor   = red %Colour of citations
}


% To change level of indentation
\newenvironment{answer}{%
\begin{list}{}{%
}%
\item[]}{\end{list}}


\makeatletter
\renewcommand{\@listI}{\itemsep=0pt} % Reduce the space between items in the itemize and enumerate environments and the bibliography
\newcommand{\imagent}[5]{
  \begin{wrapfigure}{#2}{#5\textwidth}
    \begin{center}
    \includegraphics[width=#5\textwidth]{#1}
    \end{center}
    \caption{#3}
    \label{#4}
  \end{wrapfigure}
}

\newcommand{\imagen}[4]{
  \begin{minipage}{\linewidth}
    \centering
    \includegraphics[width=#4\textwidth]{#1}
    \captionof{figure}{#2}
    \label{#3}
  \end{minipage} 
}

%Customize enumerate tag
\usepackage{enumitem}
%Sections don't get numbered
%\setcounter{secnumdepth}{0}


\usepackage{fontspec}
\setmainfont{Arial}
\usepackage{geometry}
 \geometry{
 a4paper,
 total={210mm,297mm},
 left=30mm,
 right=30mm,
 top=25mm,
 bottom=25mm,
 }
 
 
% Colours
\usepackage{xcolor}
\usepackage{colortbl}

% To include code
\usepackage{listings}

% code in bash style
\lstdefinestyle{BashInputStyle}{
  language=bash,
  basicstyle=\small\ttfamily,
  numberstyle=\tiny,
  numbersep=3pt,
  columns=fullflexible,
  backgroundcolor=\color{gray!10},
  xleftmargin=0.05\linewidth,
  showspaces=false,
  showstringspaces=false,
  breaklines=true,
}

\lstdefinestyle{pystyle}{
  language=python,
  basicstyle=\small\ttfamily,
  showspaces=false,
  showstringspaces=false
}

% changes colour of texttt
\let\oldtexttt\texttt
\renewcommand{\texttt}[2][black!60]{\textcolor{#1}{\ttfamily #2}}
\newcommand{\tcolor}[2][red]{\textcolor{#1}{#2}}


\renewcommand*{\newunitpunct}{\newline\space}
\begin{document}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% University Assignment Title Page 
% LaTeX Template
% Version 1.0 (27/12/12)
%
% This template has been downloaded from:
% http://www.LaTeXTemplates.com
%
% Original author:
% WikiBooks (http://en.wikibooks.org/wiki/LaTeX/Title_Creation)
% Modified by: NCordon (https://github.com/NCordon)
%
% License:
% CC BY-NC-SA 3.0 (http://creativecommons.org/licenses/by-nc-sa/3.0/)
% 
% Instructions for using this template:
% This title page is capable of being compiled as is. This is not useful for 
% including it in another document. To do this, you have two options: 
%
% 1) Copy/paste everything between \begin{document} and \end{document} 
% starting at \begin{titlepage} and paste this into another LaTeX file where you 
% want your title page.
% OR
% 2) Remove everything outside the \begin{titlepage} and \end{titlepage} and 
% move this file to the same directory as the LaTeX file you wish to add it to. 
% Then add \input{./title_page_1.tex} to your LaTeX file where you want your
% title page.
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{titlepage}

\newcommand{\HRule}{\rule{\linewidth}{0.5mm}} % Defines a new command for the horizontal lines, change thickness here

\center % Center everything on the page
~\\~\\~\\~\\~\\
\bigskip
%----------------------------------------------------------------------------------------
%	HEADING SECTIONS
%----------------------------------------------------------------------------------------
\textsc{\LARGE Universidad de Granada}\\[1.5cm]
\textsc{\Large Ingeniería de Servidores}\\[0.5cm] 

%----------------------------------------------------------------------------------------
%	TITLE SECTION
%----------------------------------------------------------------------------------------
\bigskip
\HRule \\[0.4cm]
{ \huge \bfseries IOStat,\\ comprobación experimental de su funcionamiento y significado de algunas medidas
que más afecten al rendimiento	}\\[0.4cm] % Title of your document
\HRule \\[1.5cm]
 
%----------------------------------------------------------------------------------------
%	AUTHOR SECTION
%----------------------------------------------------------------------------------------

\begin{minipage}{0.4\textwidth}
\begin{center} \large
%\emph{Ignacio Cordón Castillo}\\
\end{center}
\end{minipage}

%----------------------------------------------------------------------------------------
%	LOGO SECTION
%----------------------------------------------------------------------------------------

\begin{center}
\includegraphics[width=9cm]{./ugr.jpg}
\end{center}
%----------------------------------------------------------------------------------------

\vspace{\fill}% Fill the rest of the page with whitespace
\large\today
\end{titlepage}  

\newpage
\thispagestyle{empty}
\tableofcontents
\newpage
\setcounter{page}{1}
% Examples of inclussion of images
%\imagent{ugr.jpg}{Logo de prueba}{ugr}
%\imagen{ugr.jpg}{Logo de prueba}{ugr2}{size relative to the \textwidth}


\section{Resumen}
Monitorizar el empleo de discos es una función básica en las competencias de un administrador de un servidor.

A lo largo de este texto se analizará un monitor de dispositivos llamado IOStat, que viene por defecto instalado
en algunos sistemas UNIX y se constatará su funcionamiento mediante la ejecución de un experimento en que se medirán distintos tipos de medios 
de almacenamiento: se probarán distintos tipos de disco
duro: IDE,SATA,disco duro externo; distintos formatos de partición: NTFS, FAT32,\ldots; distintas revoluciones por minuto: 5400 rpm, 7200 rpm.
\section{Introducción}
Cuando como administradores de un sistema estamos en la obligación de ofrecer una determinada calidad de servicio (cubrir
necesidades mínimas de los usuarios que emplearán el sistema), y deseamos mejorar tanto la utilización de CPU como la utilización de 
memoria de disco, podemos usar un monitor de CPU o de dispositivos, respectivamente.

La pregunta es por qué es deseable optimizar esta parte de un sistema operativo, cuando hay muchos más campos que se pueden
mejorar en un sistema. La respuesta a esta pregunta se basa en que en el empleo de disco se encuentran los mayores cuellos de
botella en un ordenador. Porque una transferencia a  disco es del orden de 2000000 de veces más lenta que una transferencia a
caché de nivel L1, y del orden de 40 veces más lenta que la memoria RAM, y por tanto es potenciablemente optimizable. \cite{conferencia}

IOstat es un ejemplo de estos monitores. Se trata de un sampling monitor (monitor que funciona a intervalos regulares de
tiempo), de tipo software, que recoge información sobre el empleo de CPU y de dispositivos basándose en el empleo de la información almacenada
en los sistemas UNIX en \texttt{/proc}. Concretamente, obtiene sus datos sobre los dispositivos directamente desde
\texttt{/proc/diskstats}, no existiendo interacción con el administrador/analista. 

Entre otras cosas, nos podría ayudar a rebalancear
la carga entre discos duros; si por ejemplo tenemos varios discos duros y uno de ellos se emplea más que el resto, en términos
de cantidad de datos totales escritos o leídos, puede ayudarnos a redistribuir los archivos a los que más se accede, localizando
el disco duro en el que se encuentran; o si incluso uno de los discos duros es más rápido que el resto (información que 
también puede extraerse de los informes que genera el monitor), podemos colocar los archivos de los usuarios que más uso generen en dicho
disco duro para optimizar el sistema. 
%(?).
En muchas ocasiones, los archivos más accedidos en un sistema son los del sistema operativo, y por tanto el monitor nos podrá
ayudar a determinar a qué disco mover los archivos en función de la rapidez de cada uno. \cite{merelo}

Su uso principal es la monitarización de la memoria, ya que para la monitarización de la CPU existen herramientas mucho más
completas, como el comando de UNIX \texttt{top}, pero constituyen sólo  un front-end al sistema de archivos \texttt{/proc}, y de hecho
IOStat no puede mostrar información que un sistema UNIX de por sí tampoco pueda \cite{readme}. Su análisis de dispositivos es el aspecto en
que nos centraremos en este trabajo.

\section{Memoria}
\subsection{IOStat \cite{maniostat}}
El comando \texttt{iostat}, del paquete \texttt{sysstat} está disponible en UNIX para monitorizar tanto la carga de E/S de un sistema como el uso de la CPU. Para la monitorización E/S se basa en computar el tiempo que un dispositivo de E/S está activo en 
relación a su ratio tasa de transferencia. El comando está escrito en C, y está disponible bajo licencia GNU Public License v2.

El comando genera dos informes estadísticos: uno sobre el uso de CPU y otro sobre uso de E/S. Para mostrar cada uno, ocultando
el otro, basta usar \texttt{iostat -c} o \texttt{iostat -d} respectivamente. Respecto a las estadísticas CPU, cabe mencionar
que si se está ejecutando el comando en un sistema multiprocesador, las estadísticas mostradas constituyen una media de todos
los núcleos. Por defecto se muestran ambos informes. La primera vez que el comando ofrece información, muestra las estadísticas 
recopiladas desde la última vez que se reinició el sistema (por ejemplo siempre que ejecutemos \texttt{iostat} a secas ésta será
la salida. Las sucesivas veces se muestran estadísticas acumuladas desde la
última vez que el comando reunió información sobre el sistema. La sintaxis de la orden es:

  \begin{lstlisting}[style=BashInputStyle]
  iostat [opciones] [dispositivo] interval count
  \end{lstlisting}
  
  Donde \texttt{opciones} son los distintos flags que se le pueden pasar al comando, entre los que destacan, aparte de los ya
  mencionados:
  
  \begin{itemize}
   \item \texttt{-j \{ID | LABEL | PATH | UUID |\ldots\}}: muestra para cada dispositivo la etiqueta, el UUID,\ldots correspondiente,
   en función de lo que hayamos indicado en el comando en lugar del descriptor de dispositivo \texttt{/dev/sdX} usado para identificar a los dispositivos
   por defecto.
   \item \texttt{-k}: muestra las estadísticas expresándolas en kilobytes por segundo.
   \item \texttt{-m}: muestra las estadísticas expresándolas en megabytes por segundo.
   \item \texttt{-p}: proporciona estadísticas no sólo para cada dispositivo, sino también para las particiones presentes en cada
   dispositivo.
   \item \texttt{-t}: hace que en los informes se incluya también un timestamp con la hora a la que corresponden.
   \item \texttt{-x}: muestra estadísticas expandidas. Si no se usa esta opción, se muestran para cada dispositivo solamente
   los valores: \texttt{tps, kB\_read/s, kB\_wrtn/s, KB\_read, kB\_wrtn} (según le hayamos indicado que muestre los
   tamaños de datos -en megas o kilobytes). Si se emplea dicha opción se muestra toda la
   información descrita en \ref{optdisp}, excepto los campos mencionados anteriormente.
   \item \texttt{-y}: omite el primero de los informes (información acumulada desde el último reinicio).
   \item \texttt{-z}: omite en los informes aquellos dispositivos para los que no se registró actividad durante la acumulación
   de información.
  \end{itemize}

\texttt{interval} y \texttt{count} son dos números naturales. Son omitibles ambos, o sólo \texttt{count}. \texttt{interval} indica
a IOStat la duración del intervalo de tiempo, en segundos, durante el cual debe recopilar información; una vez vencido
ese tiempo se mostrará por pantalla un reporte de información concerniente a ese periodo de tiempo. \texttt{count} indica al comando
cuántos informes se quieren. Por ejemplo, si se llama al comando de la forma:

\begin{lstlisting}[style=BashInputStyle]
  iostat 5 10
\end{lstlisting}
  
entonces \texttt{iostat} mostrará 10 informes, uno cada 5 segundos, tanto de estadísticas CPU como de estadísticas de memoria.

Si se omite el parámetro \texttt{count} entonces \texttt{iostat} mostrará información cada vez que venza el tiempo indicado en \texttt{interval},
hasta que se interrumpa su ejecución.

Si se omiten ambos parámetros, se mostrará un único informe (CPU+memoria si no se ha indicado que se muestre uno de ellos solamente).

Por omisión se genera información para todos los dispositivos de memoria disponibles en el sistema, si no se indica lo contrario
con el parámetro \texttt{dispositivo}. Así, la siguiente llamada a \texttt{iostat}:

\begin{lstlisting}[style=BashInputStyle]
  iostat /dev/sda /dev/sdb
\end{lstlisting}

generaría información únicamente para los dispositivos correspondientes a los dispositivos de descriptores \texttt{/dev/sda} y \texttt{/dev/sdb}.

\subsubsection{Informe CPU}
La información aportada incluye:
\begin{itemize}
 \item \texttt{\%user}: porcentaje de uso CPU en el nivel usuario (generados por la ejecución de aplicaciones por parte de un usuario).
 \item \texttt{\%nice}: porcentaje de uso CPU correspondiente a procesos con prioridad cambiada.
 % Expandir
 \item \texttt{\%system}: porcentaje de uso CPU en el nivel kernel.
 \item \texttt{\%iowait}: porcentaje de tiempo que la CPU ha estado ociosa esperando a peticiones E/S.
 \item \texttt{\%steal}: porcentaje de tiempo empleado en espera por un núcleo virtual mientras el hipervisor servía a otro
 núcleo virtual. Este parámetro es útil cuando se están realizando virtualizaciones, por ejemplo con Virtualbox, y el número de
 virtualizaciones simultáneas es mayor que el número de núcleos físicos en la máquina.
 \item \texttt{\%idle}: porcentaje de tiempo que la CPU estuvo ociosa mientras el sistema no tenía una petición E/S pendiente.
\end{itemize}

\subsubsection{Informe dispositivos}
\label{optdisp}
La información mostrada puede incluir (en función de si se emplea la opción \texttt{-x} o no):
\begin{itemize}
 \item{\texttt{Device}}: descriptor de dispositivo \texttt{/dev/sdX} o de partición \texttt{/dev/sdXn}, donde \texttt{X} es una
 letra única que identifica a cada dispositivo y \texttt{n} un número que identifica de forma unívoca cada partición para un
 dispositivo dado.
 \item{\texttt{tps}}: número de transferencias por segundo a un dispositivo. Una transferencia es una petición E/S que puede
 incluir varias peticiones lógicas de E/S mezcladas. Esto es, si se intentan leer varios datos desde disco duro simultáneamente,
 puede que se hallen en el mismo bloque de disco duro o en bloques contiguos, y varias peticiones de datos dan lugar a una única
 petición de E/S. Así, una petición de E/S no tiene un tamaño fijo.
 \item{\texttt{KB\_read/s} (\texttt{MB\_read/s}}): número de KB (o MB) leídos del dispositivo por segundo.
 \item{\texttt{KB\_wrtn/s}}: (\texttt{MB\_wrtn/s}) número de KB (o MB) escritos al dispositivo por segundo.
 \item{\texttt{KB\_read}} (\texttt{MB\_read}): número de KB (o MB) leídos en total desde el dispositivo.
 \item{\texttt{KB\_wrtn}} (\texttt{MB\_wrtn}): número de KB (o MB) escritos en total al dispositivo.
 \item{\texttt{rrqm/s}}: número de peticiones de lectura mezcladas por segundo.
 \item{\texttt{wrqm/s}}: núero de peticiones de escritura mezcladas por segundo.
 \item{\texttt{r/s}}: número de peticiones de lectura(ya combinadas) completadas por segundo.
 \item{\texttt{w/s}}: número de peticiones de escritura(ya combinadas) completadas por segundo.
 \item{\texttt{rKB/s}} (\texttt{rMB/s}): equivalente a \texttt{KB\_read/s} (o \texttt{MB\_read}).
 \item{\texttt{wKB/s}} (\texttt{wMB/s}): equivalente a \texttt{KB\_wrtn/s} (o \texttt{MB\_wrtn}).
 \item{\texttt{avgrq-sz}}: tamaño medio de las peticiones, en sectores (512 bytes), emitidas
 al dispositivo.
 \item{\texttt{avgqu-sz}}: longitud media de la cola para las peticiones emitidas al dispositivo.
 \item{\texttt{await}}: media en milisegundos que tarda una petición en ser servida (incluyendo tiempo de servicio y de cola).
 \item{\texttt{r\_await}}: media en milisegundos que tarda una petición de lectura en ser servida.
 \item{\texttt{w\_await}}: media en milisegundos que tarda una petición de escritura en ser servida.
 \item{\texttt{svctm}}: media en milisegundos de tiempo de servicio para las peticiones E/S emitidas al dispositivo.
 \item{\texttt{\%util}}: bandwith del dispositivo.
\end{itemize}

\section{Evaluación de prestaciones con IOStat}
Vamos a efectuar un análisis de prestaciones sobre varios tipos de discos duros, determinando la velocidad de cada 
disco en la escritura de archivos. Efectuaremos su benchmarking empleando IOStat.

\subsection{Definición del sistema}
\imagent{system.jpg}{r}{Equipo usado para el desarrollo experimental}{system}{0.6}El principal objetivo del estudio es comparar la velocidad del copiado de archivos en varios discos duros con particiones
en distintos formatos. En otras palabras, determinar cuál es el tipo de almacenamiento más rápido. El estudio se centrará
por tanto en discos duros. Se dispondrá de dos discos duros conectados a la misma placa madre, uno que alojará los datos a
transferir, y otro que será el encargado de recibir los datos transferidos.

Obviaremos del equipo al que conectaremos los discos duros todo aquellos componentes que no interfieran en la transferencia 
de archivos o que no resulten determinantes.

\subsection{Servicios proporcionados por el sistema}
El servicio principal proporcionado por el sistema es la transferencia de datos entre discos duros.

\subsection{Métricas}
Llamaremos modelo de almacenamiento a la combinación de: sistema de archivos + tipo de conexión del disco duro + velocidad de rotación \ldots.
Para cada modelo de almacenamiento, se evaluará la velocidad de transferencia. Por tanto, la métrica empleada para evaluar las prestaciones 
del disco duro será: \textbf{número de kilobytes (o MB) escritos en el dispositivo por segundo} (\texttt{wKB/s} o \texttt{wMB/s} en IOStat).
 
 Asimismo, se hará un análisis de los siguientes datos referentes a los dispositivos, que condicionan la tasa de transferencia
 ($\approx$ velocidad de transferencia):
\begin{itemize}
 \item Número de peticiones de escritura completadas en el dispositivo por segundo. (\texttt{w/s} en IOStat).
 \item Número de peticiones de escritura mezcladas por segundo (\texttt{wrqm/s} proporciona este dato en IOStat).
 \item Tamaño de las peticiones de escritura al dispositivo (\texttt{avgrq-sz} es la media de dichos tamaños en
 IOStat).
 \item Tamaño de la cola en el dispositivo durante la transferencia. (\texttt{avgqu-sz} representa la media del
 tamaño de la cola en IOStat).
 \item Tiempo que tardan las peticiones de escritura en ser servidas. (\texttt{w\_await} proporciona la media
 de dicho tiempo en IOStat).
\end{itemize}

 También se evaluará el porcentaje de carga CPU del sistema (\texttt{\%system} + \texttt{\%user} en IOStat), 
 puesto que como se verá posteriormente condiciona mucho las transferencias en NTFS.

\subsection{Parámetros}
Los parámetros del sistema que influyen en las prestaciones serán: \cite{hddparam}
\begin{itemize}
 \item Tipo de conexión del disco duro (IDE, SATA, USB 2.0, USB 3.0 \ldots).
 \item Tamaño de memoria caché del disco duro.
 \item Velocidad de rotación del disco duro (3600, 5400, 7200 rpm).
 \item Tipo de particionado del disco duro (NTFS, FAT32, \ldots).
\end{itemize}
Se justifica el porqué hemos escogido como parámetro el tipo de conexión del disco duro, ya que como
según \cite{ide}, una conexión IDE puede alcanzar como mucho los 133 MB/s en transferencia de datos,
mientras una conexión SATA oscila entre unos 150 MB/s y 300 MB/s, y por tanto es un factor importante en la determinación
de la velocidad de escritura máxima que puede alcanzar una unidad de memoria.

La caché también influye en la velocidad, al permitir al disco duro servir peticiones de manera más fluida que si
el disco duro no dispusiese de ella. Tal y como se cita en \cite{cache}: \textit{Equilibra el flujo de datos entre la unidad de discos, 
que es relativamente lenta, y el resto del equipo al aceptar datos más deprisa de lo que pueden grabarse en el disco o leerse del mismo}.

La velocidad de rotación del disco duro, al igual que el tipo de conexión, determina la velocidad a la que pueden
escribirse los datos.

Tal y como se reflejará en los resultados, el tipo de particionado puede afectar significativamente a la velocidad de
escritura en disco.

Los parámetros de la carga que se consideran influyentes en las prestaciones son:
\begin{itemize}
 \item Tamaño de transferencia.
 \item Número de transferencias simultáneas.
\end{itemize}
Para seleccionar dichos parámetros nos hemos basado en el hecho empírico de que cuando se realiza una única transferencia,
el ancho de banda del dispositivo no alcanza el máximo, mientras que si se están realizando varias transferencias
simultáneas, el ancho de banda medio está muy cerca del 100\% y por tanto, el disco duro disminuye sus prestaciones.
\subsection{Factores}
Los factores seleccionados para este estudio son:
\begin{itemize}
 \item Tipo de conexión del disco duro.
 \item Tipo de particionado del disco duro.
 \item Tamaño de caché del disco duro.
 \item Revoluciones por minuto del disco duro.
 \item Número de transferencias simultáneas $n=1,2,\ldots5$
\end{itemize}
 A pesar de que se han seleccionado como factores los tipos de disco duro y conexión, y la velocidad de rotación, debido a 
 limitaciones de disponibilidad de hardware habrá casuísticas que no podrán evaluarse. Los
 experimentos se realizarán con el equipo sobre el que se testeará liberado de cargas innecesarias, por lo que consideraremos
 el error introducido entre medidas en distintos discos duros y el error introducido entre pruebas al mismo disco duro con distinto
 número de transferencias simultáneas insignificantes.
 
 \subsection{Técnica de evaluación}
 Se dispondrá de un equipo de sobremesa con las siguientes características hardware y software para realizar el experimento:
 \begin{itemize}
  \item Sistema Operativo: Ubuntu 14.04 LTS, 32 bits
  \item Memoria RAM: 1 GB
  \item CPU: Intel Celeron 3.06 GHz.
 \end{itemize}
 Por tanto la técnica de evaluación seleccionada es \textbf{medición sobre un sistema real}. Emplearemos el programa
 IOStat para efectuar la monitorización de la transferencia, tomando muestreos de información cada 2 segundos durante
 la transferencia de los ficheros.

 \subsection{Carga de trabajo}
 La carga consistirá en efectuar copias simultáneas de varios ficheros al disco duro. Se ha optado por mantener
 un fichero de tamaño fijo (599.8 MB) que se copiará 1,2,3\ldots 5 veces de forma simultánea desde uno de los discos
 del sistema al disco duro a evaluar.%referenciar
 
 \subsection{Diseño experimental}
 Se empleará un diseño multi-factorial fraccionado, dado que no es posible evaluar todos los niveles de todos los factores
 que afectan al rendimiento. 
 
 \subsection{Análisis de datos}
 Para contrastar los distintos datos obtenidos se efectuará una media entre los tiempos obtenidos para $1,2\ldots 5$
 transferencias simultáneas y se compararán dichas medias entre los distintos discos, determinando así empíricamente
 cuál es el disco más rápido.
 
 \section{Desarrollo experimental}
Dispondremos de varios discos duros (entre paréntesis se incluye el código por el que identificaremos al disco
de ahora en adelante): \label{discos}
\begin{itemize}
 \item [][M1] Maxtor 6K040L0, IDE, 2MB caché, 7200 rpm.
 \item [][S1] Seagate ST34321A IDE, 128KB caché, 5400 rpm.
 \item [][S2] Seagate ST320410A IDE, 2MB caché, 5400 rpm. 
 \item [][S3] Seagate ST320413A IDE, 512KB caché, 5400 rpm.
 \item [][S4] Seagate ST3320613AS SATA, 16MB caché, 7200 rpm. 
 \item [][WD1] Western Digital WD800JD SATA, 8MB caché, 7200 rpm.
 \item [][WD2] Western Digital WDBUZG0010BBK externo, USB 3.0, 5400 rpm.
\end{itemize}

Se utilizará durante el proceso la versión 10.0.2 del paquete \texttt{sysstat}.

Se emplearán particiones de tipo: ext4, FAT32, NTFS, exceptuando el disco [WD1], que sólo se ha podido evaluar
formateado en ext4. Aunque la conexión incluida en [WD2] era USB 3.0, sólo ha podido evaluarse con USB 2.0, debido
a las características del equipo empleado, que carecía de puerto USB 3.0.

Se ha confeccionado un script \texttt{bash} que recoge para los discos duros que le indiquemos(a través de su punto de montaje
en el sistema de archivos), las medias de todos los datos proporcionados por IOStat, tanto a nivel de CPU, como
en la evaluación de dispositivos en un archivo de nombre \texttt{averages}. También proporciona los datos recogidos
para cada parámetro, ordenados temporalmente según se recogieron, en un archivo de nombre \texttt{data}. Realiza 
5 iteraciones, realizando en cada iteración $i$ copias simultáneas, donde $i$ es el número de la iteración. Y almacena
los datos recogidos en una carpeta de nombre el modelo de disco duro (obtenido mediante el comando \texttt{lsblk}), con
los datos recogidos clasificados en directorios identificados por el número de copias simultáneas. El script se incluye en el
\hyperlink{script}{Anexo}

Asimismo, el mencionado script se apoya en otro realizado en \texttt{python}, de nombre \texttt{iostat\_plotter}, disponible
para su descarga en \href{https://github.com/s3h10r/iostat-plotter}{GitHub}. El software original, dado  un archivo
de salida de IOStat ejecutado de la forma:
\begin{lstlisting}[style=BashInputStyle]
 iostat -c -d -x -t -m  interval count > [archivo salida]
\end{lstlisting}
generaba un informe \texttt{.html} de los resultados, así como gráficas de ellos. El software se ha modificado
para cambiar el idioma de las gráficas, y para obtener archivos de texto plano con los resultados (medias y listado
de resultados, esto es, los archivos \texttt{averages} y \texttt{data} descritos anteriormente). Para que realizara
la segunda función descrita, se incluyó en su código, justo antes de efectuar la impresión de gráficos, el \hyperlink{pyscript}{siguiente}
código.

También se ha empleado un script bash para automatizar el proceso de dar formato a los datos. Para los archivos de
datos obtenidos, genera una tabla \LaTeX en la que además se reflejan las medias de las 5 iteraciones, para un
modelo de disco duro y un tipo de formato determinados. Se \hyperlink{gentables}{adjunta} en el anexo.
 \section{Análisis de resultados}
 Para realizar el análisis, nos basamos en los datos \hyperlink{tablas}{adjuntos}, obtenidos mediante los scripts también adjuntos.
 
 Claramente, hay que descartar los datos tomados desde [S2], dado que se observan muchos \textit{outliers} tanto en los MB/s
 transferidos como en el resto de parámetros medidos. Además, en retrospectiva, el disco duro presentó bastantes 
 dificultades para ser formateado tanto en ext4 como en FAT32. Por poner un ejemplo, se observa que con particionado
 ext4, una copia tarda 17 veces más que 3 copias simultáneas, y el doble que 5 copias simultáneas. Para FAT32 nos
 encontramos con la misma situación: una sola copia tarda 6 veces más que 2 copias simultáneas. Y 3 copias simultáneas tardan
 4 veces más que 4 copias simultaneas, según los datos recogidos. Se descartan por tanto todos los datos procedentes
 de [S2] para realizar el análisis.
 
 El modelo de almacenamiento que presenta mejores resultados para ext4 y FAT32 es el disco duro [S4], de conexión
 SATA, 16 MB de caché y 7200 rpm, obteniendo medias en ext4 y en FAT32 de 90 MB/s y 66.752 MB/s, muy superiores
 a las medias del segundo mejor disco, el [M1]: 69.238 MB/s y 40.839 MB/s, respectivamente.
 
 En contraste, el disco que mejores prestaciones presenta para el sistema de archivos NTFS es el [M1], con una
 media de 16.855 MB/s en transferencias frente a los 14.522 MB/s del [S4].
 
 Analizando en profundidad el resto de datos extraídos, se observa que el producto del número de peticiones de escritura completadas
 por segundo por el tamaño medio de las peticiones de escritura en sectores por los 0.5 KB que ocupa cada sector
 nos devuelve un dato muy próximo a la tasa de transferencia en MB/s del dispositivo, como debía de verificarse teóricamente.
 
 Resulta especialmente llamativo que la tasa de transferencia en NTFS sea en todos los casos más pequeña que la tasa
 de transferencia en ext4 y FAT32. Según los datos de que disponemos, el formato ext4 es mucho más rápido que el FAT32 y el NTFS. Este
 dato podría guardar algún tipo de correlación con el hecho de que en todos los discos evaluados la longitud de la cola
 de espera de escritura en disco es mucho menor en NTFS que en FAT32 y ext4 y se mezclan muchas más peticiones de escritura por segundo.
 Asimismo, también es observable en vista de las medias obtenidas para el experimento que el tamaño de las peticiones
 de escritura en FAT32 resulta más pequeño que en ext4 y NTFS, excepto en el caso de [WD2]. También se observa que en todos
 los discos, la carga CPU que genera una transferencia NTFS es mucho mayor que la que genera una transferencia FAT32 o una ext4,
 llegando en casos a rozar el 100\% de utilización como en las transferencias efectuadas en [M1] y [S4].
 
 Asimismo, en general, no puede afirmarse nada acerca de cómo afecta el número de transferencias simultáneas a 
 la tasa de transferencia, aunque a priori se pensaba que un mayor número de transferencias simultáneas podía dar lugar a
 una velocidad de transferencia peor, al ser el ancho de banda del disco en cuestión cercano al 100\%. Así, en las
 tablas de resultados \hyperlink{tablas}{adjuntas}, hay casos como el [M1], formateado en ext4, donde 5 transferencias
 a la vez arrojan una mayor tasa de transferencia que 1 sola copia simultánea. Y hay casuísticas como [S1] formateado en
 FAT32, donde la tasa de transferencia es mayor para una transferencia simultánea que para más transferencias simultáneas.
 
 Resulta especialmente reseñable que a pesar de ser [WD1] un disco con conexión SATA (más rápido que IDE), 4 veces más caché
 que [M1] y la misma velocidad de rotación, tenga [M1] una tasa de transferencia más alta en ext4, que es la única
 casuística que podemos evaluar, habiéndose obtenido 54.618 MB/s frente a 69.238 MB/s.
 
 Asimismo, también se observa que el disco [WD2] a pesar de ser un dispositivo externo conectado mediante USB, sea mucho
 más rápido que [S1], disco duro IDE, que es una conexión más rápida que USB 2.0 y más si cabe teniendo ambos discos el mismo número de revoluciones por minuto
 (133 MB/s de IDE, como anteriormente se ha afirmado, frente a los 480 Mbit/s (=60 MB/s) que se afirma en \cite{usbv} que posee
 una conexión USB 2.0).

 \imagen{./data/ext4/ST3320613AS/log-5/write_throughput0.png}{Througput de escritura para ext4 y 5 transferencias simultáneas en [S4]}{winfat32}{1}
 \imagen{./data/fat32/ST3320613AS/log-5/write_throughput0.png}{Througput de escritura para FAT32 y 5 transferencias simultáneas en [S4]}{winfat32}{1}
 \imagen{./data/ntfs/ST3320613AS/log-5/write_throughput0.png}{Througput de escritura para NTFS y 5 transferencias simultáneas en [S4]}{winfat32}{1}



 \newpage
 \section*{Anexo} 
 \pagenumbering{gobble}
 \subsection*{Script bash para realizar mediciones sobre discos}
 \hypertarget{script}{}
  
  \lstinputlisting[style=BashInputStyle]{./script/geninfo.sh}
  
  \subsection*{Script python (porción) para graficar resultados y obtenerlos en texto plano}
  \hypertarget{pyscript}{}
  
  \begin{lstlisting}[style=pystyle]
   # ----------------------------------------
   # Create files with useful analytics data   
   # ----------------------------------------
   
   def mean(l):
      return str(sum(l)/float(len(l))) 
   
   avg_file = open(dirname + '/averages', 'w')
   data_file = open(dirname + '/data', 'w')
   first_it = 0
   
   avg_file.write("cpu averages\n")
   avg_file.write("\tuser: " + mean(user_list) + '\n')
   avg_file.write("\tnice: " + mean(nice_list) + '\n')
   avg_file.write("\tsystem: " + mean(system_list) + '\n')
   avg_file.write("\tiowait: " + mean(iowait_list) + '\n')
   avg_file.write("\tsteal: " + mean(steal_list) + '\n')
   avg_file.write("\tidle: " + mean(idle_list) + '\n')
   
   data_file.write(str(len(device_data_list[0]["util"])) + " datos recogidos\n")
   data_file.write("\ncpu data:\n\n")
   data_file.write("user" + '\n' + str(user_list) + '\n')
   data_file.write("nice" + '\n' + str(nice_list) + '\n')
   data_file.write("system" + '\n' + str(system_list) + '\n')
   data_file.write("iowait" + '\n' + str(iowait_list) + '\n')
   data_file.write("steal" + '\n' + str(steal_list) + '\n')
   data_file.write("idle" + '\n' + str(idle_list) + '\n')

   for dev in device_data_list:
      avg_file.write(dev["device"] + " averages:\n")
      data_file.write('\n' + dev["device"] + " data:\n\n")
      
      for it in dev:            
         if (it != "device"):
            avg_file.write('\t' + it + ": " + mean(dev[it]) + '\n')		 
            data_file.write(it + '\n' + str(dev[it]) + '\n')

   avg_file.close()
   data_file.close()
  \end{lstlisting}
  
  \subsection*{Script para generar tablas \LaTeX \space a partir de los resultados}
  \hypertarget{gentables}{}
  \lstinputlisting[style=BashInputStyle]{./script/gentables.sh}
 \newpage
 \subsection*{Tablas de resultados para los distintos discos}
 \hypertarget{tablas}{}
 \input{./tex/tablas.tex}
% \input{./tex/cpu.tex}
  
\newpage
\printbibliography
\end{document}